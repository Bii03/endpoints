<!DOCTYPE html>
<html class="no-js" lang="eng" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tutorial — Microservices and Web Client</title>
    <link rel="stylesheet" href="theme/css/foundation.min.css">
    <link rel="stylesheet" href="theme/css/app.css">
     <link rel="stylesheet" href="theme/highlight.js/styles/github-gist.css">  <link rel="stylesheet" href="theme/css/mermaid.custom.css"> 
    
  </head>
  <body>
    <div class="expanded row">
      <div class="small-12 medium-12 large-12 columns align-self-top">
        <div class="row">
          
          <header class="large-12 columns align-self-top a_header">
            <div class="row">
              <div class="large-12 columns a_limited top-bar">
                <div class="top-bar-left">
                  <p>endpoints 0.4.0-SNAPSHOT</p>

                </div>
                <div class="top-bar-right align-right row">
                  
                  
                    <form action="site-search.html" method="get" class="align-right a_search">
                      <input name="q" type="search"  placeholder="Search
" >
                      <button><img alt="&#1F50D;" src="theme/images/search.svg" /></button>
                    </form>
                  
                </div>
              </div>
            </div>
          </header>
          
          <div class="small-12 medium-12 large-12 columns align-self-top a_limited a_main">
            <div class="row">
              
              <main class="columns large-order-2 sections" id="_sections">
                
                   <noscript> <blockquote class="warning">
<p>This page requires JavaScript. Please enable JavaScript in your browser.</p>
</blockquote>
 </noscript> 
                
                <h1 id="tutorial--microservices-and-web-client" class="a_section" data-magellan-target="tutorial--microservices-and-web-client">Tutorial — Microservices and Web Client<a class="a_hlink" href="#tutorial--microservices-and-web-client"></a></h1>
<p>This tutorial introduces the main features of the endpoints library
based on a complete application.</p>
<h2 id="introduction" class="a_section" data-magellan-target="introduction">Introduction<a class="a_hlink" href="#introduction"></a></h2>
<p>This section describes the application domain and architecture.
For the sake of brevity, this tutorial only shows the parts of the code
that rely on the endpoints library. The complete
source code (less than 1k lines of code) is available
<a href="https://github.com/julienrf/endpoints/tree/master/documentation/examples/cqrs">here</a>.</p>
<p>The goal of the application is to help monitoring home resource consumption (like,
for instance, electricity or water).
It provides a dashboard listing all the meters the user
is interested in and display charts showing their evolution over time:</p>
<p><img src="meters.png" alt="" /></p>
<p>Users are able to create meters, to add records (the value of a meter
at a given time) to them, and to visualize their evolution over time.</p>
<p>In order to exercise the features of the endpoints library, the application is
broken down into several sub-applications that communicate
over HTTP.</p>
<p>First, our user interface is web-based, which means that we have a
<code class="hljs">web-client</code> and a <code class="hljs">public-server</code>:</p>
<div class="mermaid" id="_id0"><pre class="mermaid_src" style="display: none">graph LR
  web-client --&gt; public-server
</pre></div>
<p>In this diagram, the <code class="hljs">web-client</code> application is a Scala.js application running in
a web browser and communicating with the <code class="hljs">public-server</code> through HTTP.</p>
<p>Second, the <code class="hljs">public-server</code> itself is broken down into smaller pieces, following a
<a href="https://martinfowler.com/bliki/CQRS.html">CQRS</a> pattern:</p>
<div class="mermaid" id="_id1"><pre class="mermaid_src" style="display: none">graph LR
  web-client --&gt; public-server
  subgraph public-server
    public-server --&gt; commands
    public-server --&gt; queries
    queries --&gt; commands
  end
</pre></div>
<p>The <code class="hljs">public-server</code> itself delegates commands processing
to the <code class="hljs">commands</code> microservice and queries processing to the <code class="hljs">queries</code>
microservice.</p>
<p>In case you are not familiar with CQRS, the idea is to have distinct microservices
handle <em>queries</em> (actions that <em>read</em> the state of the application) and <em>commands</em>
(actions that <em>update</em> the state of the application). As a benefit, the system is
more resilient (if the commands service is down, the system still works in
read-only) and more scalable (we could add multiple <code class="hljs">queries</code> nodes).</p>
<p>The <code class="hljs">commands</code> microservice validates commands and
updates the state of the system. State changes are represented as
an infinitely growing sequence of events. Then, the <code class="hljs">queries</code> microservice
builds a model from these events (hence the arrow from <code class="hljs">queries</code> to
<code class="hljs">commands</code>). This pattern is known as
<a href="https://martinfowler.com/eaaDev/EventSourcing.html">event sourcing</a>.</p>
<p>This tutorial shows how these services communicate with each
other by using the endpoints library.</p>
<p>Let’s start with the <code class="hljs">commands</code> microservice!</p>
<h2 id="describing-an-http-api" class="a_section" data-magellan-target="describing-an-http-api">Describing an HTTP API<a class="a_hlink" href="#describing-an-http-api"></a></h2>
<h3 id="project-layout" class="a_section" data-magellan-target="project-layout">Project layout<a class="a_hlink" href="#project-layout"></a></h3>
<p>In order to get our <code class="hljs">queries</code> service successfully communicate with the
<code class="hljs">commands</code> service, they have to agree on a communication protocol.</p>
<div class="mermaid" id="_id2"><pre class="mermaid_src" style="display: none">graph BT
  queries -.-&gt; commands-endpoints
  commands -.-&gt; commands-endpoints
  queries --&gt; commands
</pre></div>
<p>We introduce a new artifact named <code class="hljs">commands-endpoints</code> that provides the
<em>descriptions</em> of the endpoints of the <code class="hljs">commands</code> service. The <code class="hljs">queries</code> service
uses these descriptions to derive a <em>client</em> invoking the endpoints, while the
<code class="hljs">commands</code> service uses these descriptions to derive a <em>server</em> handling
incoming requests. (Note that in our diagrams, dotted links mean classpath
dependencies, while solid links mean communication over the wire)</p>
<p>Our <code class="hljs">commands-endpoints</code> project has to depend on the <em>endpoints algebra API</em>, which
provides means of describing HTTP endpoints:</p>
<div class="mermaid" id="_id3"><pre class="mermaid_src" style="display: none">graph BT
  queries -.-&gt; commands-endpoints
  commands -.-&gt; commands-endpoints
  queries --&gt; commands
  commands-endpoints -.-&gt; algebra[&quot;endpoints-algebra-circe&quot;]
  style algebra fill:#eee;
</pre></div>
<h3 id="describing-http-endpoints" class="a_section" data-magellan-target="describing-http-endpoints">Describing HTTP endpoints<a class="a_hlink" href="#describing-http-endpoints"></a></h3>
<p>Our <code class="hljs">commands</code> service to handles two actions:</p>
<ul>
<li>apply a command ;</li>
<li>read the event log.</li>
</ul>
<p>Here is how we define a communication protocol for these actions:</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-keyword">import</span> endpoints.algebra.{<span class="hljs-type">CirceEntities</span>, <span class="hljs-type">Endpoints</span>}

<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">CommandsEndpoints</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Endpoints</span> <span class="hljs-keyword">with</span> <span class="hljs-title">CirceEntities</span> </span>{

  <span class="hljs-comment">/**
    * Application of a command.
    *
    * Returns the produced event, or `None` in case of failure (aggregate
    * not found or invalid command).
    */</span>
  <span class="hljs-keyword">val</span> command<span class="hljs-comment">/*: Endpoint[Command, Option[StoredEvent]]*/</span> =
    endpoint(post(path / <span class="hljs-string">"command"</span>, jsonRequest[<span class="hljs-type">Command</span>]), jsonResponse[<span class="hljs-type">Option</span>[<span class="hljs-type">StoredEvent</span>]])

  <span class="hljs-comment">/**
    * Read the event long (optionally from a given timestamp).
    */</span>
  <span class="hljs-keyword">val</span> events: <span class="hljs-type">Endpoint</span>[<span class="hljs-type">Option</span>[<span class="hljs-type">Long</span>], <span class="hljs-type">Seq</span>[<span class="hljs-type">StoredEvent</span>]] =
    endpoint(get(path / <span class="hljs-string">"events"</span> /? optQs[<span class="hljs-type">Long</span>](<span class="hljs-string">"since"</span>)), jsonResponse[<span class="hljs-type">Seq</span>[<span class="hljs-type">StoredEvent</span>]])

}</code></pre>
<a href="https://github.com/julienrf/endpoints/blob/v0.4.0-SNAPSHOT/examples/cqrs/commands-endpoints/src/main/scala/cqrs/commands/CommandsEndpoints.scala#L11-L30" class="a_sourcelink">CommandsEndpoints.scala</a></div></div>
<p>Let’s explain this code line by line.</p>
<p>First, we import the <code class="hljs">Endpoints</code> and <code class="hljs">CirceEntities</code> traits from the <code class="hljs">endpoints.algebra</code> package.
All the traits that live in the <code class="hljs">algebra</code> package provide methods for <em>describing</em> HTTP endpoints.
In our case, the <a href="api/0.4.0-SNAPSHOT/index.html#endpoints.algebra.Endpoints">Endpoints</a> trait provides the core methods
while the (optional) <a href="api/0.4.0-SNAPSHOT/index.html#endpoints.algebra.CirceEntities">CirceEntities</a> trait allows us to
use <a href="https://circe.github.io/circe/">circe</a> encoders and decoders to marshal JSON entities in
requests and responses.</p>
<p>Second, we define our communication protocol within a trait, <code class="hljs">CommandsEndpoints</code>, that extends
the algebra interfaces.</p>
<p>Then, we describe the HTTP endpoint for applying a command. Because commands update the state
of the system and because state updates are represented by events, our HTTP endpoint handles
requests carrying a <code class="hljs">Command</code> and returns responses carrying an <code class="hljs">Option[StoredEvent]</code> (in
case of failure, the response is <code class="hljs">None</code>). Thus, the type of our <code class="hljs">command</code> member is
<code class="hljs">Endpoint[Command, Option[StoredEvent]]</code>. The <code class="hljs">Endpoint</code> type is provided by the endpoints
library, while the types <code class="hljs">Command</code> and <code class="hljs">StoredEvent</code> are defined by our application. Their
definition is omitted for the sake of brevity, but they are plain case classes.</p>
<p>We describe the <code class="hljs">command</code> endpoint by using the <code class="hljs">endpoint</code> constructor, which takes two
parameters, one describing the request and the other describing the response.</p>
<p>Let’s detail the request description:</p>
<ul>
<li>the <code class="hljs">post</code> method describes a request that uses the HTTP verb <code class="hljs">POST</code>,</li>
<li>the <code class="hljs">path / &quot;command&quot;</code> expression describes the URL <code class="hljs">/command</code>,</li>
<li>the <code class="hljs">jsonRequest[Command]</code> expression describes a JSON entity containing a <code class="hljs">Command</code>.</li>
</ul>
<p>The response is simply defined by the expression <code class="hljs">jsonResponse[Option[StoredEvent]]</code>,
which describes an HTTP response whose entity is a JSON document containing an
<code class="hljs">Option[StoredEvent]</code>.</p>
<p>As you can see, we describe our HTTP endpoints by combining plain Scala expressions.
The algebra interfaces provide methods that define the way we can combine these
expressions to build a complete HTTP endpoint description.</p>
<p>Now, let’s have a look at the <code class="hljs">events</code> endpoint description. This endpoint returns
the events that happened after a given optional timestamp (or all the events, if
no timestamp is supplied). Thus, its type is <code class="hljs">Endpoint[Option[Long], Seq[StoredEvent]]</code>.</p>
<p>The request description uses the method <code class="hljs">get</code>, meaning that the request uses the
<code class="hljs">GET</code> HTTP verb. The URL is described by the expression
<code class="hljs">path / &quot;events&quot; /? optQs[Long](&quot;since&quot;)</code>. Let’s break down this expression into
smaller parts:</p>
<ul>
<li>the beginning, <code class="hljs">path / &quot;events&quot;</code> is similar to the URL description
of the <code class="hljs">command</code> endpoint: it describes an URL whose path is <code class="hljs">/events</code> ;</li>
<li>the <code class="hljs">optQs[Long](&quot;since&quot;)</code> expression describes an optional query string parameter
of type <code class="hljs">Long</code> and named <code class="hljs">since</code> ;</li>
<li>finally, the <code class="hljs">/?</code> operator combines the path description and the query string
description: our URL is described by the path <code class="hljs">/events</code> followed by a query
string containing an optional parameter <code class="hljs">since</code>.</li>
</ul>
<p>Last, the response is defined by the <code class="hljs">jsonResponse[Seq[StoredEvent]]</code>
expression, which describes an HTTP response whose entity is a JSON document
containing a <code class="hljs">Seq[StoredEvent]</code>.</p>
<h3 id="summary" class="a_section" data-magellan-target="summary">Summary<a class="a_hlink" href="#summary"></a></h3>
<p>In this section we have seen that, in order to get two applications communicate
with each other, we first have to define a description of the HTTP endpoints
they will use. This one is defined in a sub-project which is depended on by
both the client and the server implementations.</p>
<p>The description of HTTP endpoints is achieved with plain Scala expressions
describing all the characteristics (verb, URL, entities, etc.) of each endpoint.</p>
<h2 id="deriving-a-server-from-a-service-description" class="a_section" data-magellan-target="deriving-a-server-from-a-service-description">Deriving a server from a service description<a class="a_hlink" href="#deriving-a-server-from-a-service-description"></a></h2>
<p>In this section we see how to implement a service from the service description
defined in the previous section.</p>
<p>The endpoints library provides <em>interpreters</em> that breathe life to inert service
descriptions.</p>
<p>A “server” interpreter implements an HTTP server that processes incoming requests
and calls the actual implementation of your service endpoints.</p>
<p>In this tutorial we will use an interpreter that uses
<a href="http://playframework.com">Play framework</a> as the underlying HTTP server. Thus, we
add the following dependency to the <code class="hljs">commands</code> project:</p>
<div class="mermaid" id="_id4"><pre class="mermaid_src" style="display: none">graph BT
  queries -.-&gt; commands-endpoints
  commands -.-&gt; commands-endpoints
  queries --&gt; commands
  commands-endpoints -.-&gt; algebra[&quot;endpoints-algebra-circe&quot;]
  commands -.-&gt; interpreter[&quot;endpoints-play-server-circe&quot;]
  style algebra fill:#eee;
  style interpreter fill:#eee;
</pre></div>
<p>Then we can create a <code class="hljs">Commands</code> object interpreting the service description as a
server as follows:</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-keyword">import</span> endpoints.play.server.{<span class="hljs-type">CirceEntities</span>, <span class="hljs-type">Endpoints</span>}
<span class="hljs-keyword">import</span> play.api.routing.<span class="hljs-type">Router</span>

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Commands</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CommandsEndpoints</span> <span class="hljs-keyword">with</span> <span class="hljs-title">Endpoints</span> <span class="hljs-keyword">with</span> <span class="hljs-title">CirceEntities</span> </span>{

  <span class="hljs-keyword">val</span> routes: <span class="hljs-type">Router</span>.<span class="hljs-type">Routes</span> = routesFromEndpoints(

    command.implementedBy(<span class="hljs-type">CommandsService</span>.apply),

    events.implementedBy(<span class="hljs-type">CommandsService</span>.events)

  )

}</code></pre>
<a href="https://github.com/julienrf/endpoints/blob/v0.4.0-SNAPSHOT/examples/cqrs/commands/src/main/scala/cqrs/commands/Commands.scala#L5-L18" class="a_sourcelink">Commands.scala</a></div></div>
<p>Again, let’s detail line by line the above code.</p>
<p>First, we import the <a href="api/0.4.0-SNAPSHOT/index.html#endpoints.play.server.Endpoints"><code class="hljs">Endpoints</code></a> and
<a href="api/0.4.0-SNAPSHOT/index.html#endpoints.play.server.CirceEntities"><code class="hljs">CirceEntities</code></a> <em>interpreters</em> from the
<code class="hljs">endpoints.play.server</code> package. Interpreters always have the same name as the
algebra interface they implement, but they are not located in the <code class="hljs">endpoints.algebra</code>
package. The <code class="hljs">endpoints.play.server</code> package contains interpreters that rely
on Play framework to implement an HTTP server.</p>
<p>Then, we extend the <code class="hljs">CommandsEndpoints</code> trait that we defined in the previous section and we
mix the <code class="hljs">Endpoints</code> and <code class="hljs">CirceEntities</code> interpreters into it. That’s really the fact that
we mix the interpreters into our service description that is responsible of giving it a
concrete semantics.</p>
<p>The semantics provided by this interpreter consists in processing incoming requests
to extract the information we are interested in (for instance, a query string parameter,
or the request entity), and building HTTP responses from the values returned by the service
implementation. In the middle of this process, we have to supply the actual service implementation.</p>
<p>We achieve this by calling the <code class="hljs">implementedBy</code> method on our endpoints. In our case, we just
delegate to a <code class="hljs">CommandsService</code> object. The underlying implementation details are not relevant
for this tutorial, but let’s just have a look at the type signature of these methods <code class="hljs">apply</code>
and <code class="hljs">events</code>:</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-comment">/**
  * Atomically applies a command to the current aggregates.
  * @return The completed event, or `None` if the command was not applicable
  */</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(command: <span class="hljs-type">Command</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">StoredEvent</span>] = <span class="hljs-comment">// …</span>
<span class="hljs-comment">/**
  * @return The sequence of events stored in the log. Events that happened
  *         before the given optional timestamp are discarded.
  */</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">events</span></span>(maybeSince: <span class="hljs-type">Option</span>[<span class="hljs-type">Long</span>]): <span class="hljs-type">Vector</span>[<span class="hljs-type">StoredEvent</span>] = <span class="hljs-comment">// …</span></code></pre>
<a href="https://github.com/julienrf/endpoints/blob/v0.4.0-SNAPSHOT/examples/cqrs/commands/src/main/scala/cqrs/commands/CommandsService.scala#L20-L66" class="a_sourcelink">CommandsService.scala</a></div></div>
<p>As you can see, the <code class="hljs">play.server</code> interpreter takes care of decoding HTTP requests and
encoding HTTP responses according to our endpoint descriptions, so that we can focus
on implementing the actual logic of our service in terms of high-level data types.</p>
<p>Finally, we create a Play <code class="hljs">Routes</code> value by using the <code class="hljs">routesFromEndpoint</code> method (provided by
the interpreter), which takes implemented endpoints as parameters and returns a Play router.</p>
<p>At this point, we can effectively start our microservice by using the usual Play API. A minimal
program achieving this would look like the following:</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-keyword">import</span> play.core.server.<span class="hljs-type">NettyServer</span>
<span class="hljs-type">NettyServer</span>.fromRouter()(<span class="hljs-type">Commands</span>.routes)
</code></pre>
</div></div>
<p>That’s it.</p>
<h3 id="summary-1" class="a_section" data-magellan-target="summary-1">Summary<a class="a_hlink" href="#summary-1"></a></h3>
<p>In this section we have mixed an interpreter to a service description
to give it a “server” semantics, which effectively decodes HTTP requests and
encodes HTTP responses according to the service description.</p>
<h2 id="deriving-a-client-from-a-service-description" class="a_section" data-magellan-target="deriving-a-client-from-a-service-description">Deriving a client from a service description<a class="a_hlink" href="#deriving-a-client-from-a-service-description"></a></h2>
<p>This section explains how to apply a “client” interpreter to a service description
and how to use it to effectively communicate with the server.</p>
<p>A “client” interpreter is the dual of a server interpreter: it encodes
HTTP requests and decodes HTTP responses.</p>
<p>Our tutorial keeps using the Play framework stack and use in particular its
<code class="hljs">WSClient</code> as the underlying HTTP client. Thus, we add the following
dependency to the <code class="hljs">queries</code> project:</p>
<div class="mermaid" id="_id5"><pre class="mermaid_src" style="display: none">graph BT
  queries -.-&gt; interpreter2[&quot;endpoints-play-client-circe&quot;]
  queries -.-&gt; commands-endpoints
  queries --&gt; commands
  commands -.-&gt; commands-endpoints
  commands-endpoints -.-&gt; algebra[&quot;endpoints-algebra-circe&quot;]
  commands -.-&gt; interpreter[&quot;endpoints-play-server-circe&quot;]
  style algebra fill:#eee;
  style interpreter fill:#eee;
  style interpreter2 fill:#eee;
</pre></div>
<p>Then we can create an <code class="hljs">eventLog</code> object interpreting the service description as
a client as follows:</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-keyword">import</span> endpoints.play.client.{<span class="hljs-type">CirceEntities</span>, <span class="hljs-type">Endpoints</span>}

<span class="hljs-comment">/** Client for the event log */</span>
<span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">eventLog</span></span>
  <span class="hljs-keyword">extends</span> <span class="hljs-type">Endpoints</span>(commandsBaseUrl, wsClient)
    <span class="hljs-keyword">with</span> <span class="hljs-type">CirceEntities</span>
    <span class="hljs-keyword">with</span> <span class="hljs-type">CommandsEndpoints</span></code></pre>
<a href="https://github.com/julienrf/endpoints/blob/v0.4.0-SNAPSHOT/examples/cqrs/queries/src/main/scala/cqrs/queries/QueriesService.scala#L31-L37" class="a_sourcelink">QueriesService.scala</a></div></div>
<p>The pattern is similar to the code applying a server interpreter: we extend our <code class="hljs">CommandsEndpoints</code>
trait and mix the <a href="api/0.4.0-SNAPSHOT/index.html#endpoints.play.client.Endpoints"><code class="hljs">endpoints.play.client.Endpoints</code></a>
and <a href="api/0.4.0-SNAPSHOT/index.html#endpoints.play.client.CirceEntities"><code class="hljs">endpoints.play.client.CirceEntities</code></a> interpreters to it.</p>
<p>The <code class="hljs">commandsBaseUrl</code> and <code class="hljs">wsClient</code> parameters (whose definition is not shown here for brevity)
define the base URL of the commands service
(e.g. <code class="hljs">http://192.168.1.50</code>) and the Play <code class="hljs">WSClient</code> instance to use to effectively perform
the HTTP requests.</p>
<p>Our queries service builds a model of the state of the application by periodically reading the events
that are appended to the log. To achieve this, it calls the <code class="hljs">events</code> endpoint of the commands
service as follows:</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-keyword">val</span> eventuallyUpdatedState: <span class="hljs-type">Future</span>[<span class="hljs-type">State</span>] =
  eventLog.events(maybeLastEventTimestamp).map { (newEvents: <span class="hljs-type">Seq</span>[<span class="hljs-type">StoredEvent</span>]) =&gt;
    atomicallyApplyEvents(newEvents)
  }</code></pre>
<a href="https://github.com/julienrf/endpoints/blob/v0.4.0-SNAPSHOT/examples/cqrs/queries/src/main/scala/cqrs/queries/QueriesService.scala#L87-L90" class="a_sourcelink">QueriesService.scala</a></div></div>
<p>From the perspective of a client, and endpoint is modeled as a function that takes as parameter
the information carried by the request and eventually returns the information carried by
the response.</p>
<p>In our case, the <code class="hljs">eventLog.events</code> endpoint is the function we want to invoke. We can
write its type signature as follows:</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala">eventLog.events: <span class="hljs-type">Option</span>[<span class="hljs-type">Long</span>] =&gt; <span class="hljs-type">Future</span>[<span class="hljs-type">Seq</span>[<span class="hljs-type">StoredEvent</span>]]
</code></pre>
</div></div>
<p>However, if you remember, we <a href="tutorial.html#describing-http-endpoints">previously</a> defined <code class="hljs">events</code> as a member
of type <code class="hljs">Endpoint[Option[Long], Seq[StoredEvent]]</code>. But now we see that its type is different.
This works because <code class="hljs">Endpoint[A, B]</code> is an abstract type member that is refined by
interpreters. Our client interpreter defines the <code class="hljs">Endpoint</code> type as follows:</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-comment">/**
  * A function that, given an `A`, eventually attempts to decode the `B` response.
  *
  * Communication failures and protocol failures are represented by a `Future.failed`.
  */</span>
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Endpoint</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>] </span>= <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Future</span>[<span class="hljs-type">B</span>]</code></pre>
</div></div>
<p>Let’s read again the code that invokes the <code class="hljs">events</code> endpoint:</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-keyword">val</span> eventuallyUpdatedState: <span class="hljs-type">Future</span>[<span class="hljs-type">State</span>] =
  eventLog.events(maybeLastEventTimestamp).map { (newEvents: <span class="hljs-type">Seq</span>[<span class="hljs-type">StoredEvent</span>]) =&gt;
    atomicallyApplyEvents(newEvents)
  }</code></pre>
<a href="https://github.com/julienrf/endpoints/blob/v0.4.0-SNAPSHOT/examples/cqrs/queries/src/main/scala/cqrs/queries/QueriesService.scala#L87-L90" class="a_sourcelink">QueriesService.scala</a></div></div>
<p>We supply a parameter, <code class="hljs">maybeLastEventTimestamp</code>, that contains the timestamp of the last event that
we applied to our projection (or <code class="hljs">None</code> if we want to rebuild the entire projection).</p>
<p>The invocation returns a <code class="hljs">Future[Seq[StoredEvent]]</code>, we <code class="hljs">map</code> it transform the events into
an updated model of the system.</p>
<h3 id="summary-2" class="a_section" data-magellan-target="summary-2">Summary<a class="a_hlink" href="#summary-2"></a></h3>
<p>We have seen how to derive a client from a service description and how to use
this client to communicate with the server (that was derived from the same service
description).</p>
<p>The communication between microservices is achieved through a statically typed API.</p>
<p>From a developer perspective, remotely invoking an endpoint of a microservice
consists in calling a function.</p>
<h2 id="multiplexed-endpoints" class="a_section" data-magellan-target="multiplexed-endpoints">Multiplexed endpoints<a class="a_hlink" href="#multiplexed-endpoints"></a></h2>
<p>This section shows how the endpoints of the “queries” microservice are defined.
This microservice supports query operations like “find all”, “find by id”, etc.</p>
<p>Since this microservice is only called internally by our public server
we don’t really care about using a nice REST interface for our communication.</p>
<p>For instance, instead of using one HTTP endpoint per operation (<code class="hljs">findAll</code>,
<code class="hljs">findById</code>, etc.) we can define a single HTTP endpoint taking as parameter
either a “find all” type of query or a “find by id” type of query, and
returning the corresponding result(s).</p>
<p>Endpoints that handle several operations at once are called <em>multiplexed
endpoints</em>.</p>
<h3 id="multiplexed-endpoint-description" class="a_section" data-magellan-target="multiplexed-endpoint-description">Multiplexed endpoint description<a class="a_hlink" href="#multiplexed-endpoint-description"></a></h3>
<p>The difference between a non-multiplexed endpoint and a multiplexed endpoint
is that the former has one type describing the HTTP request and one type
describing the HTTP response, whereas in a multiplexed endpoint several
types of request are supported, and the type of the response depends on the
actual type of the request.</p>
<p>We can see how this is reflected in the types. A non-multiplexed endpoint
for the “find by id” operation would describe a request carrying an id
of type <code class="hljs">String</code> and a response carrying an <code class="hljs">Option[Meter]</code>. The resulting
endpoint would have type
<a href="api/0.4.0-SNAPSHOT/index.html#endpoints.algebra.Endpoints@Endpoint[A,B]"><code class="hljs">Endpoint[String, Option[Meter]]</code></a>.</p>
<p>If we wanted to also handle the “find all” operation with the same endpoint,
what would be the type of the response description? In the case of the “find
by id” operation, this would still be <code class="hljs">Option[Meter]</code>, but in the case of the
“find all” operation, this would be <code class="hljs">List[Meter]</code>. It is worth noting
that the type of the response depends on the type of the request.
Non-multiplexed endpoints can not express that.</p>
<p>Here is how we can define a multiplexed endpoint handling both operations:</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-keyword">val</span> query: <span class="hljs-type">MuxEndpoint</span>[<span class="hljs-type">QueryReq</span>, <span class="hljs-type">QueryResp</span>, <span class="hljs-type">Json</span>] = {
  <span class="hljs-keyword">val</span> request = post(path / <span class="hljs-string">"query"</span>, jsonRequest[<span class="hljs-type">Json</span>])
  muxEndpoint[<span class="hljs-type">QueryReq</span>, <span class="hljs-type">QueryResp</span>, <span class="hljs-type">Json</span>](request, jsonResponse)
}</code></pre>
<a href="https://github.com/julienrf/endpoints/blob/v0.4.0-SNAPSHOT/examples/cqrs/queries-endpoints/src/main/scala/cqrs/queries/QueriesEndpoints.scala#L20-L23" class="a_sourcelink">QueriesEndpoints.scala</a></div></div>
<p>The type of this multiplexed endpoint is
<a href="api/0.4.0-SNAPSHOT/index.html#endpoints.algebra.Endpoints@MuxEndpoint[Req%3C:endpoints.algebra.MuxRequest,Resp,Transport]"><code class="hljs">MuxEndpoint[QueryReq, QueryResp, Json]</code></a>.
It describes an HTTP endpoint that handles request types that are subtypes of <code class="hljs">QueryReq</code>
and response types that subtypes of <code class="hljs">QueryResp</code>, and that uses JSON documents to marshal information.</p>
<p>The <code class="hljs">QueryReq</code> type defines the possible types of requests:</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">QueryReq</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MuxRequest</span></span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FindById</span>(<span class="hljs-params">id: <span class="hljs-type">UUID</span>, after: <span class="hljs-type">Option</span>[<span class="hljs-type">Long</span>]</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">QueryReq</span> </span>{ <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Response</span> </span>= <span class="hljs-type">MaybeResource</span> }
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">FindAll</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">QueryReq</span> </span>{ <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Response</span> </span>= <span class="hljs-type">ResourceList</span> }</code></pre>
<a href="https://github.com/julienrf/endpoints/blob/v0.4.0-SNAPSHOT/examples/cqrs/queries-endpoints/src/main/scala/cqrs/queries/QueriesEndpoints.scala#L30-L32" class="a_sourcelink">QueriesEndpoints.scala</a></div></div>
<p>It is defined as a <code class="hljs">sealed trait</code> that extends <code class="hljs">MuxRequest</code> and whose each alternative (<code class="hljs">FindAll</code>
and <code class="hljs">FindById</code>) sets the <code class="hljs">Response</code> type member to its corresponding response type.</p>
<p>The <code class="hljs">FindById</code> request type carries the information of the “find by id” operation:
the <code class="hljs">id</code> of the meter to look up, and an optional event timestamp
that can be used to get consistency between writes and reads.</p>
<p>The <code class="hljs">FindAll</code> request type is the type of requests performing a “find all” operation.</p>
<blockquote class="note">
<p>Alternatives <em>have to</em> be qualified as <code class="hljs">final</code>, otherwise the type system will
fail to compile calls to the endpoint.</p>
</blockquote>
<p>The <code class="hljs">QueryResp</code> type defines the possible types of responses as a regular
algebraic data type:</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">QueryResp</span></span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaybeResource</span>(<span class="hljs-params">value: <span class="hljs-type">Option</span>[<span class="hljs-type">Meter</span>]</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">QueryResp</span></span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceList</span>(<span class="hljs-params">value: <span class="hljs-type">List</span>[<span class="hljs-type">Meter</span>]</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">QueryResp</span></span></code></pre>
<a href="https://github.com/julienrf/endpoints/blob/v0.4.0-SNAPSHOT/examples/cqrs/queries-endpoints/src/main/scala/cqrs/queries/QueriesEndpoints.scala#L44-L46" class="a_sourcelink">QueriesEndpoints.scala</a></div></div>
<p>The <code class="hljs">MaybeResource</code> type carries the information of a response to a “find
by id” request (an optional <code class="hljs">Meter</code>), and the <code class="hljs">ResourceList</code> type carries
the information of a response to a “find all” request (a list of <code class="hljs">Meter</code>s).</p>
<h3 id="invoking-a-multiplexed-endpoint" class="a_section" data-magellan-target="invoking-a-multiplexed-endpoint">Invoking a multiplexed endpoint<a class="a_hlink" href="#invoking-a-multiplexed-endpoint"></a></h3>
<p>Our public server delegates to the queries service by invoking the
multiplexed endpoints defined in the previous section.</p>
<p>To invoke an endpoint as a client, we first have to derive a client for
the endpoint descriptions:</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-keyword">package</span> cqrs.publicserver

<span class="hljs-keyword">import</span> endpoints.play.client.{<span class="hljs-type">CirceEntities</span>, <span class="hljs-type">Endpoints</span>}
<span class="hljs-keyword">import</span> cqrs.queries.<span class="hljs-type">QueriesEndpoints</span>
<span class="hljs-keyword">import</span> play.api.libs.ws.<span class="hljs-type">WSClient</span>

<span class="hljs-keyword">import</span> scala.concurrent.<span class="hljs-type">ExecutionContext</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueriesClient</span>(<span class="hljs-params">baseUrl: <span class="hljs-type">String</span>, wsClient: <span class="hljs-type">WSClient</span></span>)(<span class="hljs-params">implicit ec: <span class="hljs-type">ExecutionContext</span></span>)</span>
  <span class="hljs-keyword">extends</span> <span class="hljs-type">Endpoints</span>(baseUrl, wsClient)
    <span class="hljs-keyword">with</span> <span class="hljs-type">CirceEntities</span>
    <span class="hljs-keyword">with</span> <span class="hljs-type">QueriesEndpoints</span></code></pre>
<a href="https://github.com/julienrf/endpoints/blob/v0.4.0-SNAPSHOT/examples/cqrs/public-server/src/main/scala/cqrs/publicserver/QueriesClient.scala" class="a_sourcelink">QueriesClient.scala</a></div></div>
<p>The process is the same as in the first part of the tutorial: we extend
the trait that defines the endpoint descriptions (<code class="hljs">QueriesEndpoints</code>)
with traits that provide a client implementation (here, using the play framework
under the hood).</p>
<p>Once we have derived a client implementation, we can invoke the <code class="hljs">query</code> endpoint
like so:</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> queriesClient = <span class="hljs-keyword">new</span> <span class="hljs-type">QueriesClient</span>(queriesBaseUrl, wsClient)
<span class="hljs-keyword">val</span> metersList: <span class="hljs-type">Future</span>[<span class="hljs-type">ResourceList</span>] = queriesClient.query(<span class="hljs-type">FindAll</span>)</code></pre>
<a href="https://github.com/julienrf/endpoints/blob/v0.4.0-SNAPSHOT/examples/cqrs/public-server/src/main/scala/cqrs/publicserver/PublicServer.scala" class="a_sourcelink">PublicServer.scala</a></div></div>
<p>We first instantiate the client and then invoke the <code class="hljs">query</code> endpoint with a <code class="hljs">FindAll</code> request.
We get a result of type <code class="hljs">Future[ResourceList]</code>.</p>
<p>We can also invoke the “find by id” operation as follows:</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-keyword">val</span> maybeMeter: <span class="hljs-type">Future</span>[<span class="hljs-type">MaybeResource</span>] = queriesClient.query(<span class="hljs-type">FindById</span>(id, after = <span class="hljs-type">Some</span>(t)))</code></pre>
<a href="https://github.com/julienrf/endpoints/blob/v0.4.0-SNAPSHOT/examples/cqrs/public-server/src/main/scala/cqrs/publicserver/PublicServer.scala" class="a_sourcelink">PublicServer.scala</a></div></div>
<p>Note that here the return type is <code class="hljs">Future[MaybeResource]</code>.</p>
<p>In order to get the <code class="hljs">query</code> endpoint return different result types according to the type
of the value that is passed as parameter (<code class="hljs">FindAll</code> vs <code class="hljs">FindById</code>), we use an advanced
Scala feature named “path-dependent types”.</p>
<p>From a client point of view, a simplified type signature of the <code class="hljs">apply</code> method of a <code class="hljs">MuxEndpoint</code>
could be the following:</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">MuxEndpoint</span>[<span class="hljs-type">Req</span> &lt;: <span class="hljs-type">MuxRequest</span>, <span class="hljs-type">Resp</span>, <span class="hljs-type">Transport</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(req: <span class="hljs-type">Req</span>): <span class="hljs-type">Future</span>[req.<span class="hljs-type">Response</span>]
}
</code></pre>
</div></div>
<p>Translated in english, it means that one can invoke a <code class="hljs">MuxEndpoint</code> by passing it a <code class="hljs">Req</code> parameter,
and the result is a <code class="hljs">Future[req.Response]</code>. The important part is the <code class="hljs">req.Response</code> type: that’s
the <code class="hljs">Response</code> type member of the <code class="hljs">req</code> parameter. Thus, if we pass a <code class="hljs">FindAll</code> request, we get
a result of type <code class="hljs">ResourceList</code> because <code class="hljs">FindAll</code> defines its <code class="hljs">Response</code> type to <code class="hljs">ResourceList</code>.</p>
<h3 id="implementing-a-multiplexed-endpoint" class="a_section" data-magellan-target="implementing-a-multiplexed-endpoint">Implementing a multiplexed endpoint<a class="a_hlink" href="#implementing-a-multiplexed-endpoint"></a></h3>
<p>Our queries microservice uses Play framework as an underlying HTTP server. Thus, we derive
a server implementation of the <code class="hljs">QueriesEndpoint</code> by mixing the <code class="hljs">endpoints.play.server.Endpoints</code>
trait in it.</p>
<p>Then, the essence of the implementation consists in pattern matching on the supplied <code class="hljs">QueryReq</code>
parameter:</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala">query <span class="hljs-keyword">match</span> {
  <span class="hljs-keyword">case</span> <span class="hljs-type">FindById</span>(id, t) =&gt; service.findById(id, t).map(<span class="hljs-type">MaybeResource</span>)
  <span class="hljs-keyword">case</span> <span class="hljs-type">FindAll</span>         =&gt; service.findAll().map(<span class="hljs-type">ResourceList</span>)
}</code></pre>
<a href="https://github.com/julienrf/endpoints/blob/v0.4.0-SNAPSHOT/examples/cqrs/queries/src/main/scala/cqrs/queries/Queries.scala#L22-L25" class="a_sourcelink">Queries.scala</a></div></div>
<p>Here we use a <code class="hljs">service</code> abstraction that contains the actual implementation of the operations.
We just transform the results of these operations into the <code class="hljs">Response</code> type corresponding
to each <code class="hljs">QueryReq</code> (e.g. <code class="hljs">MaybeResource</code> in the case of <code class="hljs">FindById</code>, etc.).</p>
<p>The complete implementation of the <code class="hljs">query</code> multiplexed endpoint is a bit more complex:</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-keyword">import</span> endpoints.play.server.<span class="hljs-type">MuxHandlerAsync</span>

<span class="hljs-keyword">val</span> routes: <span class="hljs-type">Router</span>.<span class="hljs-type">Routes</span> = routesFromEndpoints(

  query.implementedByAsync(<span class="hljs-keyword">new</span> <span class="hljs-type">MuxHandlerAsync</span>[<span class="hljs-type">QueryReq</span>, <span class="hljs-type">QueryResp</span>] {
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>[<span class="hljs-type">R</span> &lt;: <span class="hljs-type">QueryResp</span>](query: <span class="hljs-type">QueryReq</span> { <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Response</span> </span>= <span class="hljs-type">R</span> }): <span class="hljs-type">Future</span>[<span class="hljs-type">R</span>] =
      query <span class="hljs-keyword">match</span> {
        <span class="hljs-keyword">case</span> <span class="hljs-type">FindById</span>(id, t) =&gt; service.findById(id, t).map(<span class="hljs-type">MaybeResource</span>)
        <span class="hljs-keyword">case</span> <span class="hljs-type">FindAll</span>         =&gt; service.findAll().map(<span class="hljs-type">ResourceList</span>)
      }
  })

)</code></pre>
<a href="https://github.com/julienrf/endpoints/blob/v0.4.0-SNAPSHOT/examples/cqrs/queries/src/main/scala/cqrs/queries/Queries.scala#L15-L29" class="a_sourcelink">Queries.scala</a></div></div>
<p>We wrapped our match expression into a <code class="hljs">MuxHandlerAsync</code>, whose definition is the following:</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-comment">/**
  * A function whose return type depends on the type
  * of the given `req`.
  *
  * @tparam Req Request base type
  * @tparam Resp Response base type
  */</span>
<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">MuxHandlerAsync</span>[<span class="hljs-type">Req</span> &lt;: <span class="hljs-type">MuxRequest</span>, <span class="hljs-type">Resp</span>] </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>[<span class="hljs-type">R</span> &lt;: <span class="hljs-type">Resp</span>](req: <span class="hljs-type">Req</span> { <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Response</span> </span>= <span class="hljs-type">R</span> }): <span class="hljs-type">Future</span>[<span class="hljs-type">R</span>]
}</code></pre>
</div></div>
<p>This complex type signature is necessary to check that our implementation effectively
returns a value that corresponds to the <code class="hljs">Response</code> type member of the passed request.</p>
<h3 id="summary-3" class="a_section" data-magellan-target="summary-3">Summary<a class="a_hlink" href="#summary-3"></a></h3>
<p>A multiplexed endpoint is an HTTP endpoint that can handle several operations. It can be useful
to implement an internal communication protocol.</p>
<p>To describe a multiplexed endpoint you have to first reify the possible request types and their
respective response type as data types.</p>
<h2 id="scalajs-client" class="a_section" data-magellan-target="scalajs-client">Web client<a class="a_hlink" href="#scalajs-client"></a></h2>
<p>The previous sections have shown how to achieve internal communication between the microservices of our
<code class="hljs">public-server</code> application.</p>
<p>This section describes the implementation of the HTTP API between external clients and our public
server.</p>
<div class="mermaid" id="_id6"><pre class="mermaid_src" style="display: none">graph LR
  web-client --&gt; public-server
</pre></div>
<p>The difference with the previous sections is that since this API is public we really want to reuse most of the
features of the HTTP protocol instead of re-implementing them on top of HTTP. For instance, requesting a non-
existing resource should return a 404 (Not Found) response (whereas in our internal <code class="hljs">query</code> service we would get
a 200 (OK) response containing a <code class="hljs">MaybeResource</code> entity whose <code class="hljs">value</code> would be <code class="hljs">None</code>).</p>
<p>For the sake of illustration, our <code class="hljs">web-client</code> will use this public API.</p>
<h3 id="public-api-description" class="a_section" data-magellan-target="public-api-description">Public API description<a class="a_hlink" href="#public-api-description"></a></h3>
<p>As usual, we introduce a <code class="hljs">public-endpoints</code> project containing the endpoints description:</p>
<div class="mermaid" id="_id7"><pre class="mermaid_src" style="display: none">graph BT
  web-client -.-&gt; interpreter2[&quot;endpoints-xhr-client-circe&quot;]
  web-client -.-&gt; public-endpoints
  web-client --&gt; public-server
  public-server -.-&gt; public-endpoints
  public-endpoints -.-&gt; algebra[&quot;endpoints-algebra-circe&quot;]
  public-server -.-&gt; interpreter[&quot;endpoints-play-server-circe&quot;]
  style algebra fill:#eee;
  style interpreter fill:#eee;
  style interpreter2 fill:#eee;
</pre></div>
<p>The <code class="hljs">endpoints-xhr-client-circe</code> dependency provides a Scala.js interpreter that derives a client from endpoint
descriptions.</p>
<p>The public endpoints description defines four endpoints: <code class="hljs">listMeters</code>, <code class="hljs">getMeter</code>, <code class="hljs">createMeter</code>
and <code class="hljs">addRecord</code>:</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-keyword">import</span> endpoints.algebra.{<span class="hljs-type">CirceEntities</span>, <span class="hljs-type">Endpoints</span>, <span class="hljs-type">OptionalResponses</span>}

<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">PublicEndpoints</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Endpoints</span> <span class="hljs-keyword">with</span> <span class="hljs-title">CirceEntities</span> <span class="hljs-keyword">with</span> <span class="hljs-title">OptionalResponses</span> </span>{

  <span class="hljs-comment">/** Common path prefix for endpoints: “/meters” */</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> metersPath = path / <span class="hljs-string">"meters"</span>

  <span class="hljs-comment">/** Lists all the registered meters */</span>
  <span class="hljs-keyword">val</span> listMeters: <span class="hljs-type">Endpoint</span>[<span class="hljs-type">Unit</span>, <span class="hljs-type">List</span>[<span class="hljs-type">Meter</span>]] =
    endpoint(get(metersPath), jsonResponse[<span class="hljs-type">List</span>[<span class="hljs-type">Meter</span>]])

  <span class="hljs-comment">/** Find a meter by id */</span>
  <span class="hljs-keyword">val</span> getMeter: <span class="hljs-type">Endpoint</span>[<span class="hljs-type">UUID</span>, <span class="hljs-type">Option</span>[<span class="hljs-type">Meter</span>]] =
    endpoint(get(metersPath / segment[<span class="hljs-type">UUID</span>]), option(jsonResponse[<span class="hljs-type">Meter</span>]))

  <span class="hljs-comment">/** Registers a new meter */</span>
  <span class="hljs-keyword">val</span> createMeter<span class="hljs-comment">/*: Endpoint[CreateMeter, Meter]*/</span> =
    endpoint(post(metersPath, jsonRequest[<span class="hljs-type">CreateMeter</span>]), jsonResponse[<span class="hljs-type">Meter</span>])

  <span class="hljs-comment">/** Add a record to an existing meter */</span>
  <span class="hljs-keyword">val</span> addRecord<span class="hljs-comment">/*: Endpoint[(UUID, AddRecord), Meter]*/</span> =
    endpoint(post(metersPath / segment[<span class="hljs-type">UUID</span>] / <span class="hljs-string">"records"</span>, jsonRequest[<span class="hljs-type">AddRecord</span>]), jsonResponse[<span class="hljs-type">Meter</span>])

  <span class="hljs-keyword">implicit</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">uuidSegment</span></span>: <span class="hljs-type">Segment</span>[<span class="hljs-type">UUID</span>]

}</code></pre>
<a href="https://github.com/julienrf/endpoints/blob/v0.4.0-SNAPSHOT/examples/cqrs/public-endpoints/src/main/scala/cqrs/publicserver/PublicEndpoints.scala#L19-L46" class="a_sourcelink">PublicEndpoints.scala</a></div></div>
<p>We have already seen most of the used combinators that describe the endpoints. The <code class="hljs">getMeter</code> endpoint
uses some new combinators, though:</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-keyword">val</span> getMeter: <span class="hljs-type">Endpoint</span>[<span class="hljs-type">UUID</span>, <span class="hljs-type">Option</span>[<span class="hljs-type">Meter</span>]] =
  endpoint(get(metersPath / segment[<span class="hljs-type">UUID</span>]), option(jsonResponse[<span class="hljs-type">Meter</span>]))</code></pre>
<a href="https://github.com/julienrf/endpoints/blob/v0.4.0-SNAPSHOT/examples/cqrs/public-endpoints/src/main/scala/cqrs/publicserver/PublicEndpoints.scala#L32-L33" class="a_sourcelink">PublicEndpoints.scala</a></div></div>
<p>The URL is described by the expression <code class="hljs">metersPath / segment[UUID]</code>, which means the <code class="hljs">/meters</code>
URL prefix followed by a segment containing an <code class="hljs">UUID</code>. A <code class="hljs">segment[X]</code> expression describes
a path segment that maps to a value of type <code class="hljs">X</code>.</p>
<p>It is worth noting that the endpoint library provides no support for <code class="hljs">UUID</code>s, but this one
can retroactively be added (as we do in this example): the <code class="hljs">segment[A]</code> method takes an implicit
parameter of type <code class="hljs">Segment[A]</code> that defines how to encode or decode the <code class="hljs">A</code> value into a
path segment (thus, invoking <code class="hljs">segment[X]</code> with an unsupported type <code class="hljs">X</code> would raise an error at
compile-time). Since this encoding or decoding process is the responsibility of the interpreter,
and since we are only describing the endpoint, we added an abstract implicit method of type
<code class="hljs">Segment[UUID]</code>, which will be implemented by interpreters.</p>
<p>The response of the <code class="hljs">getMeter</code> endpoint is described by the expression
<code class="hljs">option(jsonResponse[Meter])</code>, which means that it
can optionally be empty (for instance if a client queries this endpoint with a
non-existing <code class="hljs">UUID</code>). The <code class="hljs">option</code> method, provided by the <code class="hljs">OptionalResponses</code> algebra
interface, takes a <code class="hljs">Response[A]</code> description and
turns it into a <code class="hljs">Response[Option[A]]</code>, mapping the <code class="hljs">None</code> case
to a 404 (Not Found) response.</p>
<h3 id="client-and-server-implementations" class="a_section" data-magellan-target="client-and-server-implementations">Client and server implementations<a class="a_hlink" href="#client-and-server-implementations"></a></h3>
<p>The server implementation is very similar to what has been previously shown: we create a
type that inherits from <code class="hljs">PublicEndpoints</code> and the relevant interpreters. The only new thing
is that we have to implement the abstract <code class="hljs">uuidSegment: Segment[UUID]</code> member. In our
server interpreter based on Play, the <code class="hljs">Segment</code> type is defined as follows:</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-comment">/** Defines how to decode and encode path segments */</span>
<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Segment</span>[<span class="hljs-type">A</span>] </span>{
  <span class="hljs-comment">/** @param segment URL decoded path segment */</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decode</span></span>(segment: <span class="hljs-type">String</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">A</span>]
  <span class="hljs-comment">/** @return URL encoded path segment */</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">encode</span></span>(a: <span class="hljs-type">A</span>): <span class="hljs-type">String</span>
}</code></pre>
</div></div>
<p>The <code class="hljs">decode</code> method is used when routing an incoming request, while the <code class="hljs">encode</code> method is
used for “reverse routing” (ie to generate (valid) URLs of endpoints).</p>
<p>The implementation of the <code class="hljs">uuidSegment</code> member is straightforward:</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> uuidSegment: <span class="hljs-type">Segment</span>[<span class="hljs-type">UUID</span>] =
  <span class="hljs-keyword">new</span> <span class="hljs-type">Segment</span>[<span class="hljs-type">UUID</span>] {
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decode</span></span>(segment: <span class="hljs-type">String</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">UUID</span>] = <span class="hljs-type">Try</span>(<span class="hljs-type">UUID</span>.fromString(segment)).toOption
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">encode</span></span>(uuid: <span class="hljs-type">UUID</span>): <span class="hljs-type">String</span> = <span class="hljs-type">URLEncoder</span>.encode(uuid.toString, utf8Name)
  }</code></pre>
<a href="https://github.com/julienrf/endpoints/blob/v0.4.0-SNAPSHOT/examples/cqrs/public-server/src/main/scala/cqrs/publicserver/PublicServer.scala#L78-L82" class="a_sourcelink">PublicServer.scala</a></div></div>
<p>The client implementation is also straightforward: we create a type that inherits from
<code class="hljs">PublicEndpoints</code> and the relevant interpreters. In our case, we use an interpreter that
derives a client performing <code class="hljs">XMLHttpRequest</code>s to invoke the endpoints.</p>
<p>Again, we have to implement the <code class="hljs">uuidSegment</code> member. In our interpreter the <code class="hljs">Segment</code> type
is defined as follows:</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-comment">/** Defines how to build a path segment from an `A` */</span>
<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Segment</span>[<span class="hljs-type">A</span>] </span>{
  <span class="hljs-comment">/** @return An URL encoded path segment (e.g. "foo%2Fbar") */</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">encode</span></span>(a: <span class="hljs-type">A</span>): <span class="hljs-type">String</span>
}</code></pre>
</div></div>
<p>Thus, we define the <code class="hljs">uuidSegment</code> like so:</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-keyword">implicit</span> <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> uuidSegment: <span class="hljs-type">Segment</span>[<span class="hljs-type">UUID</span>] =
  (uuid: <span class="hljs-type">UUID</span>) =&gt; stringSegment.encode(uuid.toString)</code></pre>
<a href="https://github.com/julienrf/endpoints/blob/v0.4.0-SNAPSHOT/examples/cqrs/web-client/src/main/scala/cqrs/webclient/PublicEndpoints.scala#L14-L15" class="a_sourcelink">PublicEndpoints.scala</a></div></div>
<p>Finally, here is an example of invocation of the <code class="hljs">listMeters</code> endpoint from the Scala.js client:</p>
<div class="row"><div class="a_linked small-expand columns a_xscroll a_codeblock">
<pre class="hljs"><code class="language-scala"><span class="hljs-type">PublicEndpoints</span>.listMeters(()).map { fetchedMeters =&gt;
  metersVar := fetchedMeters.map(meter =&gt; meter.id -&gt; meter).toMap
}</code></pre>
<a href="https://github.com/julienrf/endpoints/blob/v0.4.0-SNAPSHOT/examples/cqrs/web-client/src/main/scala/cqrs/webclient/Main.scala#L25-L27" class="a_sourcelink">Main.scala</a></div></div>
<h3 id="summary-4" class="a_section" data-magellan-target="summary-4">Summary<a class="a_hlink" href="#summary-4"></a></h3>
<p>In this section we have seen that deriving a Scala.js client works the same way as deriving a JVM
client.</p>
<p>We have seen that the endpoints library provides a minimal infrastructure that is designed to
be extended according to application-specific needs. In our case we saw how the <code class="hljs">OptionalResponses</code>
introduced a new method for describing responses such that empty responses are mapped to
a 404 (Not Found) response. We also saw how support for custom data types (e.g. <code class="hljs">UUID</code>) can
be introduced.</p>

              </main>
              
              
                <div data-sticky-container class="small-12 medium-12 large-2 large-order-1 columns a_sitenav_container">
                  <nav class="a_sitenav" data-sticky data-sticky-on="large" data-anchor="_sections">
                    
                  <ul>
                     
  <li >
    
      <a href="index.html">Introduction</a>
    
    
  </li>
  
  <li >
    
      <a href="overview.html">Overview</a>
    
    
  </li>
  
  <li >
    
      <a href="installation.html">Installation</a>
    
    
  </li>
  
  <li  class="a_thispage" >
    
      <a href="tutorial.html">Tutorial — Microservices and Web Client</a>
    
    
  </li>
  
  <li >
    
      <a href="tutorial-openapi.html">Tutorial — OpenAPI</a>
    
    
  </li>
  
  <li >
    
      <a href="design.html">Design in a nutshell</a>
    
    
  </li>
  
  <li >
    
      <a href="interfaces-and-interpreters.html">Algebra interfaces and their interpreters</a>
    
    
  </li>
  
  <li >
    
      <a href="comparison.html">Comparison with similar tools</a>
    
    
  </li>
  
  <li >
    
      <a href="talks.html">Talks and Publications</a>
    
    
  </li>
 
                  </ul>
                  </nav>
                </div>
              
              
              
                <div class="small-12 medium-12 large-2 large-order-3 columns a_show-for-xlarge" data-sticky-container>
                  <nav class="a_pagenav" data-sticky data-sticky-on="large" data-anchor="_sections">
                     <header><p>On This Page</p>
</header> 
                    <ul class="vertical menu" data-magellan>
                       
  <li>
    
       <a href="#tutorial--microservices-and-web-client">Tutorial — Microservices and Web Client</a> 
    
    
      <ul class="vertical menu">  
  <li>
    
       <a href="#introduction">Introduction</a> 
    
    
  </li>
  
  <li>
    
       <a href="#describing-an-http-api">Describing an HTTP API</a> 
    
    
      <ul class="vertical menu">  
  <li>
    
       <a href="#project-layout">Project layout</a> 
    
    
  </li>
  
  <li>
    
       <a href="#describing-http-endpoints">Describing HTTP endpoints</a> 
    
    
  </li>
  
  <li>
    
       <a href="#summary">Summary</a> 
    
    
  </li>
  </ul>
    
  </li>
  
  <li>
    
       <a href="#deriving-a-server-from-a-service-description">Deriving a server from a service description</a> 
    
    
      <ul class="vertical menu">  
  <li>
    
       <a href="#summary-1">Summary</a> 
    
    
  </li>
  </ul>
    
  </li>
  
  <li>
    
       <a href="#deriving-a-client-from-a-service-description">Deriving a client from a service description</a> 
    
    
      <ul class="vertical menu">  
  <li>
    
       <a href="#summary-2">Summary</a> 
    
    
  </li>
  </ul>
    
  </li>
  
  <li>
    
       <a href="#multiplexed-endpoints">Multiplexed endpoints</a> 
    
    
      <ul class="vertical menu">  
  <li>
    
       <a href="#multiplexed-endpoint-description">Multiplexed endpoint description</a> 
    
    
  </li>
  
  <li>
    
       <a href="#invoking-a-multiplexed-endpoint">Invoking a multiplexed endpoint</a> 
    
    
  </li>
  
  <li>
    
       <a href="#implementing-a-multiplexed-endpoint">Implementing a multiplexed endpoint</a> 
    
    
  </li>
  
  <li>
    
       <a href="#summary-3">Summary</a> 
    
    
  </li>
  </ul>
    
  </li>
  
  <li>
    
       <a href="#scalajs-client">Web client</a> 
    
    
      <ul class="vertical menu">  
  <li>
    
       <a href="#public-api-description">Public API description</a> 
    
    
  </li>
  
  <li>
    
       <a href="#client-and-server-implementations">Client and server implementations</a> 
    
    
  </li>
  
  <li>
    
       <a href="#summary-4">Summary</a> 
    
    
  </li>
  </ul>
    
  </li>
  </ul>
    
  </li>
 
                    </ul>
                  </nav>
                </div>
              
            </div>
          </div>
        </div>
      </div>
      
      <footer class="small-12 medium-12 large-12 columns align-self-bottom a_footer">
        <div class="row">
          <div class="small-12 medium-12 large-12 columns top-bar">
            <div class="top-bar-left">
              
            </div>
            <div class="top-bar-right">
              <p>Generated with <a href="https://github.com/szeiger/ornate">Ornate</a>.</p>

            </div>
          </div>
        </div>
      </footer>
    </div>
    <script src="theme/js/jquery.min.js"></script>
    <script src="theme/js/what-input.min.js"></script>
    <script src="theme/js/foundation.min.js"></script>
     <script src="theme/js/mermaidAPI-0.5.8.min.js"></script> 
    <script src="theme/js/app.js"></script>
    
  </body>
</html>
